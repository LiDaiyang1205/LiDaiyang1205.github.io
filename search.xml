<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C++学习（3）--类与对象]]></title>
    <url>%2F2019%2F09%2F05%2FC%2B%2B%E5%AD%A6%E4%B9%A0%EF%BC%883%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1 面向对象程序设计的基本特点 抽象：解释类与对象之间关系的词。类与对象之间的关系就是抽象的关系。一句话来说明：类是对象的抽象，而对象则是类得特例，即类的具体表现形式。 封装：封装是面向对象编程的核心思想。将对象的属性和行为封装起来,其载体就是类,类通常会对客户隐藏其实现细节,这就是封装的思想。 继承：子类继承父类，可以继承父类原有的属性和方法，也可以增加其他的属性和方法，可以直接重写父类中的某些方法。 多态：多态性一般是指在父类中定义的方法被子类继承后，可以表现出不同的行为。这使得同一个方法在父类及其各个子类中具有不同的语义。 2 类和对象2.1 类的定义语法形式如下： 123456789class 类名称&#123;public: 外部接口private: 私有成员protected: 保护型成员&#125; 2.2类成员的访问控制public:公有类型，类的外部接口。 private:私有类型，只能被本类的成员函数访问，来自类外部的任何访问都是非法的。 protected:保护类型，和私有类型类似，差别在于继承过程中对产生的新类的影响不同。 2.3 对象类的对象是该类的某一特定实体，即类类型的变量。 声明形式： 12类名 对象；Clock myClock； 类中成员互访：直接使用成员名 类外访问：使用“对象名.成员名” 方式访问public属性成员 2.4 类的成员函数实现形式 1234返回值类型 类名：：函数成员名（参数表）&#123; 函数体&#125; 例子 12345678910111213141516171819202122232425262728293031323334353637//设置时钟#include &lt;iostream&gt;using namespace std;class Clock&#123; //时钟类的定义public: //外部接口 void setTime(int newH=0, int newM=0, int newS=0); void showTime();private: //私有数据成员 int hour,minute,second;&#125;;//时钟类函数的实现void Clock::setTime(int newH, int newM, int newS) &#123; hour = newH; minute = newM; second = newS;&#125;inline void Clock::showTime() &#123; cout&lt;&lt;hour&lt;&lt;":"&lt;&lt;minute&lt;&lt;":"&lt;&lt;second&lt;&lt;endl;&#125;//主函数int main()&#123; Clock myClock; //定义对象myClock cout&lt;&lt;"First time set and output:"&lt;&lt;endl; myClock.setTime(); myClock.showTime(); cout&lt;&lt;"Second time set and output:"&lt;&lt;endl; myClock.setTime(22,10,30); myClock.showTime(); return (0);&#125; 3 构造函数和析构函数3.1 构造函数构造函数的作用是在对象被创建时利用特定的值构造对象，将对象初始化为一个特定的状态。 123456789101112131415161718192021222324252627282930313233343536373839404142434445//设置时钟#include &lt;iostream&gt;using namespace std;class Clock&#123; //时钟类的定义public: //外部接口 Clock (int newH, int newM, int newS); //构造函数 void setTime(int newH=0, int newM=0, int newS=0); void showTime();private: //私有数据成员 int hour,minute,second;&#125;;//构造函数的实现Clock::Clock(int newH, int newM, int newS) &#123; hour = newH; minute = newM; second = newS;&#125;//时钟类函数的实现void Clock::setTime(int newH, int newM, int newS) &#123; hour = newH; minute = newM; second = newS;&#125;inline void Clock::showTime() &#123; cout&lt;&lt;hour&lt;&lt;":"&lt;&lt;minute&lt;&lt;":"&lt;&lt;second&lt;&lt;endl;&#125;//主函数int main()&#123; Clock myClock(1,2,3); //定义对象myClock cout&lt;&lt;"First time set and output:"&lt;&lt;endl; myClock.showTime(); cout&lt;&lt;"Second time set and output:"&lt;&lt;endl; myClock.setTime(22,10,30); myClock.showTime(); return (0);&#125; 3.2 复制构造函数复制构造函数是一种特殊的构造函数，其形参是本类的对象的引用。作用是使用一个已经存在的对象（由复制构造函数的参数指定），去初始化同类的一个新的对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//设置时钟#include &lt;iostream&gt;using namespace std;class Point&#123; //Point 类的定义public: // 外部接口 Point(int xx=0, int yy=0)&#123; // 构造函数 x=xx; y=yy; &#125; Point(Point &amp;p); //复制构造函数 int getX()&#123; return x; &#125; int getY()&#123; return y; &#125;private: // 私有数据 int x, y;&#125;;// 成员函数的实现Point::Point(Point &amp;p) &#123; x=p.x; y=p.y; cout&lt;&lt;"呼叫复制构造函数"&lt;&lt;endl;&#125;// 形参为Point类对象的函数void fun1(Point p)&#123; cout&lt;&lt;p.getX()&lt;&lt;endl;&#125;//返回值为Point类对象的函数Point fun2()&#123; Point a(1,2); return a;&#125;// 主函数int main()&#123; Point a(4,5); //第一个对象a Point b=a; //用法1，用a初始化b cout&lt;&lt;b.getX()&lt;&lt;endl; fun1(b); // 用法2，对象b作为fun1的实参 b=fun2(); // 用法3，函数的返回值是类对象，函数返回时，调用复制构造函数 cout&lt;&lt;b.getX()&lt;&lt;endl; return (0);&#125; 3.3 析构函数作用与构造函数正好相反，用来完成对象被删除前的一些清理工作。在对象生存期即将结束的时刻被自动调用，不接受任何参数，也没有返回值。 4 类的组合类的组合描述的是一个类内嵌套其他类的对象作为成员的情况，是一种包含与被包含的关系。 当创建类的对象时，如果这个类具有内嵌对象成员，那么各个内嵌对象将首先被自动创建。在创建对象时，既要对本类的基本类型数据成员进行初始化，又要对内嵌对象成员进行初始化。 例子 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//Line 类的例子#include &lt;iostream&gt;#include &lt;cmath&gt; //数学函数using namespace std;class Point&#123; //Point 类定义public: Point(int xx=0, int yy=0)&#123; // 构造函数 x=xx; y=yy; &#125; Point(Point &amp;p); //复制构造函数 int getX()&#123; return x; &#125; int getY()&#123; return y; &#125;private: // 私有数据 int x, y;&#125;;// 成员函数的实现Point::Point(Point &amp;p) &#123; x=p.x; y=p.y; cout&lt;&lt;"呼叫复制构造函数"&lt;&lt;endl;&#125;// 类的组合class Line&#123; // Line类的定义public: Line(Point xp1, Point xp2); Line(Line &amp;l); double getLen() &#123; return len;&#125;private: Point p1, p2; double len;&#125;;// 组合类的构造函数Line::Line(Point xp1, Point xp2) :p1(xp1),p2(xp2)&#123; cout&lt;&lt;"呼叫Line的构造函数:"&lt;&lt;endl; double x= static_cast&lt;double&gt;(p1.getX()-p2.getX()); double y= static_cast&lt;double&gt;(p1.getY()-p2.getY()); len = sqrt(x*x+y*y);&#125;// 组合类的复制构造函数Line::Line(Line &amp;l):p1(l.p1),p2(l.p2) &#123; cout&lt;&lt;"呼叫Line的复制构造函数:"&lt;&lt;endl; len=l.len;&#125;// 主函数int main()&#123; Point myp1(1,1), myp2(4,5); Line line(myp1,myp2); Line line2(line); cout&lt;&lt;"Line的长度为:"&lt;&lt;endl; cout&lt;&lt;line.getLen()&lt;&lt;endl; cout&lt;&lt;"Line2的长度为:"&lt;&lt;endl; cout&lt;&lt;line2.getLen()&lt;&lt;endl; return (0);&#125;]]></content>
      <categories>
        <category>语言学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++学习（2）--函数]]></title>
    <url>%2F2019%2F09%2F04%2FC%2B%2B%E5%AD%A6%E4%B9%A0%EF%BC%882%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1 函数的定义与使用1.1 函数定义的语法形式1234567类型说明符 函数名（含类型说明的形参表）&#123;​ 语句序列&#125; 1.2 函数的调用调用前先声明： 1类型说明符 函数名（含类型说明的形参表）; 再调用： 1函数名（实参表） 一般调用 12345678910111213141516//求x的n次方#include &lt;iostream&gt;using namespace std;double power(double x, int n);int main()&#123; cout &lt;&lt; "5 to the power 2 is "&lt;&lt; power(5,2) &lt;&lt;endl; return 0;&#125;double power(double x, int n)&#123; double val=1.0; while (n--) val *= x; return val;&#125; 嵌套调用 12345678910111213141516171819//求两个数平方和#include &lt;iostream&gt;using namespace std;int fun2(int m)&#123; return m*m;&#125;int fun1(int x, int y)&#123; return fun2(x)+fun2(y);&#125;int main()&#123; int a, b; cout&lt;&lt;"请输入两个数："; cin&gt;&gt;a&gt;&gt;b; cout&lt;&lt;"它们的平方和为："&lt;&lt;fun1(a,b)&lt;&lt;endl; return 0;&#125; 递归调用 1234567891011121314151617181920//求n的阶乘#include &lt;iostream&gt;using namespace std;unsigned fac(unsigned n)&#123; unsigned f; if (n==0) f=1; else f=fac(n-1)*n; return f;&#125;int main()&#123; unsigned n; cout&lt;&lt;"输入一个正整数："; cin&gt;&gt;n; unsigned y=fac(n); cout&lt;&lt;n&lt;&lt;"!="&lt;&lt;y&lt;&lt;endl; return 0;&#125; 1.3 函数的参数传递值传递（单项传递） 12345678910111213141516//交换两个数#include &lt;iostream&gt;using namespace std;void swap (int a, int b)&#123; int t = a; a=b; b=t;&#125;int main()&#123; int x=5, y=10; cout &lt;&lt; "x="&lt;&lt;x&lt;&lt;" y="&lt;&lt;y&lt;&lt;endl; swap(x,y); cout &lt;&lt; "x="&lt;&lt;x&lt;&lt;" y="&lt;&lt;y&lt;&lt;endl; return 0;&#125; 输出： 12x=5 y=10x=5 y=10 引用传递（双向） 12345678910111213141516//交换两个数#include &lt;iostream&gt;using namespace std;void swap (int &amp;a, int &amp;b)&#123; int t = a; a=b; b=t;&#125;int main()&#123; int x=5, y=10; cout &lt;&lt; "x="&lt;&lt;x&lt;&lt;" y="&lt;&lt;y&lt;&lt;endl; swap(x,y); cout &lt;&lt; "x="&lt;&lt;x&lt;&lt;" y="&lt;&lt;y&lt;&lt;endl; return 0;&#125; 输出： 12x=5 y=10x=10 y=5 2 C++系统函数 C++系统提供很多自带的函数，如数学函数，平方根（sqrt)，求绝对值（abs）等等。 只需要用include指令嵌入相应的头文件，就可以使用系统函数。如数学函数，只需在开头写： 1#include &lt;cmath&gt;]]></content>
      <categories>
        <category>语言学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++学习（1）--基础]]></title>
    <url>%2F2019%2F08%2F29%2FC%2B%2B%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1 命名空间避免命名冲突 std是C++标准库的命名空间（ namespace）名 using namespace std表示打开std命名空间 12345678910111213#include &lt;iostream&gt;using namespace std;int main() &#123; cout &lt;&lt; "Hello!" &lt;&lt; endl; cout &lt;&lt; "Welcome to c++!" &lt;&lt; endl; return 0;&#125; 运行结果： Hello! Welcome to c++！ 2 基本运算12345678910111213141516#include &lt;iostream&gt;using namespace std;int main() &#123; const int PRICE = 30; // 整数常量 int num, total; // 初始化 double v, r, h; num = 10; // 赋值 total = num * PRICE; cout &lt;&lt; total &lt;&lt; endl; r = 2.5; h = 3.2; v = 3.14159 * r * r * h; cout &lt;&lt; v &lt;&lt; endl; return 0;&#125; 运行结果： 30062.8318 注意：1/2为0，1/2.0为0.5 。 3 数据输入输出 “&lt;&lt;”是预定义的插入符，作用在流类对象cout上便可以实现项标准输出设备输出。 1cout &lt;&lt; 表达式 &lt;&lt; 表达式... 标准输入是将提取符作用在流类对象cin上。 1cin &gt;&gt; 表达式 &gt;&gt; 表达式... 提取符可以连续写多个，每个后面跟一个表达式，该表达式通常是用于存放输入值的变量。例如： 123int a, b;cin &gt;&gt; a &gt;&gt; b; 常用的I/O流类库操纵符 例： 1234567#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;int main() &#123; cout &lt;&lt; setw(5) &lt;&lt; setprecision(3) &lt;&lt; 3.1415; return 0;&#125; 输出 3.14 4 算法基本控制结构4.1 if 语句12345678910111213141516171819//判断是不是闰年#include &lt;iostream&gt;using namespace std;int main()&#123; int year; bool isLeapYear; cout &lt;&lt; "Enter the year: "; cin &gt;&gt; year; isLeapYear = ((year % 4 == 0 &amp;&amp; year % 100 != 0) || (year % 400 == 0)); if (isLeapYear) cout &lt;&lt; year &lt;&lt; " is a leap year" &lt;&lt; endl; else cout &lt;&lt; year &lt;&lt; " is not a leap year" &lt;&lt; endl; return 0;&#125; 注意：如果if else 语句里面还有if else语句，最好有{}来确定层次关系，否则在省略else情况下会出错。 4.2 switch 语句1234567891011121314151617181920212223242526//判断星期几#include &lt;iostream&gt;using namespace std;int main()&#123; int day; cin &gt;&gt; day; switch (day)&#123; case 0: cout &lt;&lt; "星期天" &lt;&lt; endl; break; case 1: cout &lt;&lt; "星期一" &lt;&lt; endl; break; case 2: cout &lt;&lt; "星期二" &lt;&lt; endl; break; case 3: cout &lt;&lt; "星期三" &lt;&lt; endl; break; case 4: cout &lt;&lt; "星期四" &lt;&lt; endl; break; case 5: cout &lt;&lt; "星期五" &lt;&lt; endl; break; case 6: cout &lt;&lt; "星期六" &lt;&lt; endl; break; &#125; return 0;&#125; 4.3 while 语句12345678910111213//计算1加到10#include &lt;iostream&gt;using namespace std;int main()&#123; int i = 1, sum = 0; while (i &lt;= 10)&#123; sum += i; i++; &#125; cout &lt;&lt; "sum = " &lt;&lt; sum &lt;&lt; endl; return 0;&#125; 4.4 do while 语句12345678910111213//计算1加到10#include &lt;iostream&gt;using namespace std;int main()&#123; int i = 1, sum = 0; do&#123; sum += i; i++; &#125;while (i &lt;= 10); cout &lt;&lt; "sum = " &lt;&lt; sum &lt;&lt; endl; return 0;&#125; 4.5 for 语句123456789101112131415//求一个整数所有因子#include &lt;iostream&gt;using namespace std;int main()&#123; int n; cout &lt;&lt; "Enter a positive integer: "; cin &gt;&gt; n; cout &lt;&lt; "Number " &lt;&lt; n &lt;&lt; " Factors "; for (int k=1; k&lt;=n; k++) if (n%k==0) cout &lt;&lt; k &lt;&lt; " "; cout &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>语言学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ORB_SLAM2地图保存与加载（2）]]></title>
    <url>%2F2019%2F08%2F27%2FORB_SLAM2%E5%9C%B0%E5%9B%BE%E4%BF%9D%E5%AD%98%E4%B8%8E%E5%8A%A0%E8%BD%BD%EF%BC%882%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本文记录了ORB_SLAM2中地图加载的过程。参考博客：https://blog.csdn.net/qq_34254510/article/details/79969046http://www.cnblogs.com/mafuqiang/p/6972841.htmlhttps://blog.csdn.net/felaim/article/details/79667635https://blog.csdn.net/u014709760/article/details/86319090 2 地图加载2.1 源码修改地图加载部分需要修改的较多，所以按所需修改的文件来进行说明。 （1）Map相关文件修改在Map.h文件中声明地图加载函数、地图点加载函数和关键帧加载函数： 1234//加载地图信息 void Load(const string &amp;filename,SystemSetting* mySystemSetting); MapPoint* LoadMapPoint(ifstream &amp;f); KeyFrame* LoadKeyFrame(ifstream &amp;f,SystemSetting* mySystemSetting); Map.h中需要加入SystemSetting.h： 1234#include "SystemSetting.h"### 还要添加class SystemSetting; 在Map.cc文件中进行相应实现： 地图加载函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293//地图加载函数void Map::Load ( const string &amp;filename, SystemSetting* mySystemSetting)&#123; cerr &lt;&lt; "Map.cc :: Map reading from:"&lt;&lt;filename&lt;&lt;endl; ifstream f; f.open( filename.c_str() ); // Same as the sequence that we save the file, we first read the number of MapPoints. unsigned long int nMapPoints; f.read((char*)&amp;nMapPoints, sizeof(nMapPoints)); // Then read MapPoints one after another, and add them into the map cerr&lt;&lt;"Map.cc :: The number of MapPoints:"&lt;&lt;nMapPoints&lt;&lt;endl; for ( unsigned int i = 0; i &lt; nMapPoints; i ++ ) &#123; MapPoint* mp = LoadMapPoint(f); AddMapPoint(mp); &#125; // Get all MapPoints std::vector&lt;MapPoint*&gt; vmp = GetAllMapPoints(); // Read the number of KeyFrames unsigned long int nKeyFrames; f.read((char*)&amp;nKeyFrames, sizeof(nKeyFrames)); cerr&lt;&lt;"Map.cc :: The number of KeyFrames:"&lt;&lt;nKeyFrames&lt;&lt;endl; // Then read KeyFrames one after another, and add them into the map vector&lt;KeyFrame*&gt;kf_by_order; for( unsigned int i = 0; i &lt; nKeyFrames; i ++ ) &#123; KeyFrame* kf = LoadKeyFrame(f, mySystemSetting); AddKeyFrame(kf); kf_by_order.push_back(kf); &#125; cerr&lt;&lt;"Map.cc :: Max KeyFrame ID is: " &lt;&lt; mnMaxKFid &lt;&lt; ", and I set mnId to this number" &lt;&lt;endl; cerr&lt;&lt;"Map.cc :: KeyFrame Load OVER!"&lt;&lt;endl; // Read Spanning Tree(open loop trajectory) map&lt;unsigned long int, KeyFrame*&gt; kf_by_id; for ( auto kf: mspKeyFrames ) kf_by_id[kf-&gt;mnId] = kf; cerr&lt;&lt;"Map.cc :: Start Load The Parent!"&lt;&lt;endl; for( auto kf: kf_by_order ) &#123; // Read parent_id of current KeyFrame. unsigned long int parent_id; f.read((char*)&amp;parent_id, sizeof(parent_id)); // Add parent KeyFrame to current KeyFrame. // cout&lt;&lt;"Map::Load : Add parent KeyFrame to current KeyFrame"&lt;&lt;endl; if ( parent_id != ULONG_MAX ) kf-&gt;ChangeParent(kf_by_id[parent_id]); // Read covisibility graphs. // Read the number of Connected KeyFrames of current KeyFrame. unsigned long int nb_con; f.read((char*)&amp;nb_con, sizeof(nb_con)); // Read id and weight of Connected KeyFrames of current KeyFrame, // and add Connected KeyFrames into covisibility graph. // cout&lt;&lt;"Map::Load : Read id and weight of Connected KeyFrames"&lt;&lt;endl; for ( unsigned long int i = 0; i &lt; nb_con; i ++ ) &#123; unsigned long int id; int weight; f.read((char*)&amp;id, sizeof(id)); f.read((char*)&amp;weight, sizeof(weight)); kf-&gt;AddConnection(kf_by_id[id],weight); &#125; &#125; cerr&lt;&lt;"Map.cc :: Parent Load OVER!"&lt;&lt;endl; for ( auto mp: vmp ) &#123; // cout &lt;&lt; "Now mp = "&lt;&lt; mp &lt;&lt; endl; if(mp) &#123; // cout &lt;&lt; "compute for mp = "&lt;&lt; mp &lt;&lt; endl; mp-&gt;ComputeDistinctiveDescriptors(); // cout &lt;&lt; "Computed Distinctive Descriptors." &lt;&lt; endl; mp-&gt;UpdateNormalAndDepth(); // cout &lt;&lt; "Updated Normal And Depth." &lt;&lt; endl; &#125; &#125; f.close(); cerr&lt;&lt;"Map.cc :: Load IS OVER!"&lt;&lt;endl; return;&#125; 其过程就是根据保存的顺序依次加载地图点的数目、地图点、关键帧的数目、关键帧、生长树和关联关系。 地图点加载函数： 123456789101112131415161718MapPoint* Map::LoadMapPoint( ifstream &amp;f )&#123; // Position and Orientation of the MapPoints. cv::Mat Position(3,1,CV_32F); long unsigned int id; f.read((char*)&amp;id, sizeof(id)); f.read((char*)&amp;Position.at&lt;float&gt;(0), sizeof(float)); f.read((char*)&amp;Position.at&lt;float&gt;(1), sizeof(float)); f.read((char*)&amp;Position.at&lt;float&gt;(2), sizeof(float)); // Initialize a MapPoint, and set its id and Position. MapPoint* mp = new MapPoint(Position, this ); mp-&gt;mnId = id; mp-&gt;SetWorldPos( Position ); return mp;&#125; 关键帧加载函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485KeyFrame* Map::LoadKeyFrame( ifstream &amp;f, SystemSetting* mySystemSetting )&#123; InitKeyFrame initkf(*mySystemSetting); // Read ID and TimeStamp of each KeyFrame. f.read((char*)&amp;initkf.nId, sizeof(initkf.nId)); f.read((char*)&amp;initkf.TimeStamp, sizeof(double)); // Read position and quaternion cv::Mat T = cv::Mat::zeros(4,4,CV_32F); std::vector&lt;float&gt; Quat(4); //Quat.reserve(4); for ( int i = 0; i &lt; 4; i ++ ) f.read((char*)&amp;Quat[i],sizeof(float)); cv::Mat R = Converter::toCvMat(Quat); for ( int i = 0; i &lt; 3; i ++ ) f.read((char*)&amp;T.at&lt;float&gt;(i,3),sizeof(float)); for ( int i = 0; i &lt; 3; i ++ ) for ( int j = 0; j &lt; 3; j ++ ) T.at&lt;float&gt;(i,j) = R.at&lt;float&gt;(i,j); T.at&lt;float&gt;(3,3) = 1; // Read feature point number of current Key Frame f.read((char*)&amp;initkf.N, sizeof(initkf.N)); initkf.vKps.reserve(initkf.N); initkf.Descriptors.create(initkf.N, 32, CV_8UC1); vector&lt;float&gt;KeypointDepth; std::vector&lt;MapPoint*&gt; vpMapPoints; vpMapPoints = vector&lt;MapPoint*&gt;(initkf.N,static_cast&lt;MapPoint*&gt;(NULL)); // Read Keypoints and descriptors of current KeyFrame std::vector&lt;MapPoint*&gt; vmp = GetAllMapPoints(); for(int i = 0; i &lt; initkf.N; i ++ ) &#123; cv::KeyPoint kp; f.read((char*)&amp;kp.pt.x, sizeof(kp.pt.x)); f.read((char*)&amp;kp.pt.y, sizeof(kp.pt.y)); f.read((char*)&amp;kp.size, sizeof(kp.size)); f.read((char*)&amp;kp.angle,sizeof(kp.angle)); f.read((char*)&amp;kp.response, sizeof(kp.response)); f.read((char*)&amp;kp.octave, sizeof(kp.octave)); initkf.vKps.push_back(kp); // Read descriptors of keypoints f.read((char*)&amp;initkf.Descriptors.cols, sizeof(initkf.Descriptors.cols)); // for ( int j = 0; j &lt; 32; j ++ ) // Since initkf.Descriptors.cols is always 32, for loop may also write like this. for ( int j = 0; j &lt; initkf.Descriptors.cols; j ++ ) f.read((char*)&amp;initkf.Descriptors.at&lt;unsigned char&gt;(i,j),sizeof(char)); // Read the mapping from keypoints to MapPoints. unsigned long int mpidx; f.read((char*)&amp;mpidx, sizeof(mpidx)); // Look up from vmp, which contains all MapPoints, MapPoint of current KeyFrame, and then insert in vpMapPoints. if( mpidx == ULONG_MAX ) vpMapPoints[i] = NULL; else vpMapPoints[i] = vmp[mpidx]; &#125; initkf.vRight = vector&lt;float&gt;(initkf.N,-1); initkf.vDepth = vector&lt;float&gt;(initkf.N,-1); //initkf.vDepth = KeypointDepth; initkf.UndistortKeyPoints(); initkf.AssignFeaturesToGrid(); // Use initkf to initialize a KeyFrame and set parameters KeyFrame* kf = new KeyFrame( initkf, this, NULL, vpMapPoints ); kf-&gt;mnId = initkf.nId; kf-&gt;SetPose(T); kf-&gt;ComputeBoW(); for ( int i = 0; i &lt; initkf.N; i ++ ) &#123; if ( vpMapPoints[i] ) &#123; vpMapPoints[i]-&gt;AddObservation(kf,i); if( !vpMapPoints[i]-&gt;GetReferenceKeyFrame()) vpMapPoints[i]-&gt;SetReferenceKeyFrame(kf); &#125; &#125; return kf;&#125; （2）MapPoint相关文件修改由于在加载地图时我们只有Position以及当前的Map，所以需要重新定义一种MapPoint类的构造函数以满足要求。 在MapPoint.h文件中添加如下构造函数： 123MapPoint(const cv::Mat &amp;Pos,Map* pMap);KeyFrame* SetReferenceKeyFrame(KeyFrame* RFKF); 在MapPoint.cc文件中实现该构造函数： 123456789101112MapPoint::MapPoint(const cv::Mat &amp;Pos, Map* pMap): mnFirstKFid(0), mnFirstFrame(0), nObs(0), mnTrackReferenceForFrame(0), mnLastFrameSeen(0), mnBALocalForKF(0), mnFuseCandidateForKF(0), mnLoopPointForKF(0), mnCorrectedByKF(0), mnCorrectedReference(0), mnBAGlobalForKF(0), mpRefKF(static_cast&lt;KeyFrame*&gt;(NULL)), mnVisible(1), mnFound(1), mbBad(false), mpReplaced(static_cast&lt;MapPoint*&gt;(NULL)), mfMinDistance(0), mfMaxDistance(0), mpMap(pMap) &#123; Pos.copyTo(mWorldPos); mNormalVector = cv::Mat::zeros(3,1,CV_32F); // MapPoints can be created from Tracking and Local Mapping. This mutex avoid conflicts with id. unique_lock&lt;mutex&gt; lock(mpMap-&gt;mMutexPointCreation); mnId=nNextId++; &#125; 此外，还需要添加如下函数： 1234KeyFrame* MapPoint::SetReferenceKeyFrame(KeyFrame* RFKF)&#123; return mpRefKF = RFKF;&#125; （3）KeyFrame相关文件修改与MapPoint文件相同，KeyFrame文件也要做相关修改。 在KeyFrame.h文件中添加如下构造函数： 1KeyFrame(InitKeyFrame &amp;initkf,Map* pMap,KeyFrameDatabase* pKFDB,vector&lt;MapPoint*&gt;&amp; vpMapPoints); 不要忘记在KeyFrame.h中添加相应头文件和命名空间中的类声明 12345678#include "MapPoint.h"#include "Thirdparty/DBoW2/DBoW2/BowVector.h"#include "Thirdparty/DBoW2/DBoW2/FeatureVector.h"#include "ORBVocabulary.h"#include "ORBextractor.h"#include "Frame.h"#include "KeyFrameDatabase.h"#include "InitKeyFrame.h" 123456789class Map;class MapPoint;class Frame;class KeyFrameDatabase;class InitKeyFrame;class KeyFrame&#123;public: 在KeyFrame.cc文件中实现该构造函数： 123456789101112131415161718KeyFrame::KeyFrame(InitKeyFrame &amp;initkf, Map *pMap, KeyFrameDatabase *pKFDB, vector&lt;MapPoint*&gt; &amp;vpMapPoints): mnFrameId(0), mTimeStamp(initkf.TimeStamp), mnGridCols(FRAME_GRID_COLS), mnGridRows(FRAME_GRID_ROWS), mfGridElementWidthInv(initkf.fGridElementWidthInv), mfGridElementHeightInv(initkf.fGridElementHeightInv), mnTrackReferenceForFrame(0), mnFuseTargetForKF(0), mnBALocalForKF(0), mnBAFixedForKF(0), mnLoopQuery(0), mnLoopWords(0), mnRelocQuery(0), mnRelocWords(0), mnBAGlobalForKF(0), fx(initkf.fx), fy(initkf.fy), cx(initkf.cx), cy(initkf.cy), invfx(initkf.invfx), invfy(initkf.invfy), mbf(initkf.bf), mb(initkf.b), mThDepth(initkf.ThDepth), N(initkf.N), mvKeys(initkf.vKps), mvKeysUn(initkf.vKpsUn), mvuRight(initkf.vRight), mvDepth(initkf.vDepth), mDescriptors(initkf.Descriptors.clone()), mBowVec(initkf.BowVec), mFeatVec(initkf.FeatVec), mnScaleLevels(initkf.nScaleLevels), mfScaleFactor(initkf.fScaleFactor), mfLogScaleFactor(initkf.fLogScaleFactor), mvScaleFactors(initkf.vScaleFactors), mvLevelSigma2(initkf.vLevelSigma2),mvInvLevelSigma2(initkf.vInvLevelSigma2), mnMinX(initkf.nMinX), mnMinY(initkf.nMinY), mnMaxX(initkf.nMaxX), mnMaxY(initkf.nMaxY), mK(initkf.K), mvpMapPoints(vpMapPoints), mpKeyFrameDB(pKFDB), mpORBvocabulary(initkf.pVocabulary), mbFirstConnection(true), mpParent(NULL), mbNotErase(false), mbToBeErased(false), mbBad(false), mHalfBaseline(initkf.b/2), mpMap(pMap) &#123; mnId = nNextId ++; &#125; （4）SystemSetting和InitKeyFrame相关文件在上面的函数中我们用到了SystemSetting类和InitKeyFrame类。其中SystemSetting类用于读取参数文件中的相关参数，InitKeyFrame类用于进行关键帧初始化。其实现过程如下： 创建 SystemSetting.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#ifndef SYSTEMSETTING_H#define SYSTEMSETTING_H#include&lt;string&gt;#include"ORBVocabulary.h"#include&lt;opencv2/opencv.hpp&gt;namespace ORB_SLAM2 &#123; class SystemSetting&#123; public: SystemSetting(ORBVocabulary* pVoc); bool LoadSystemSetting(const std::string strSettingPath); public: ORBVocabulary* pVocavulary; //相机参数 float width; float height; float fx; float fy; float cx; float cy; float invfx; float invfy; float bf; float b; float fps; cv::Mat K; cv::Mat DistCoef; bool initialized; //相机 RGB 参数 int nRGB; //ORB特征参数 int nFeatures; float fScaleFactor; int nLevels; float fIniThFAST; float fMinThFAST; //其他参数 float ThDepth = -1; float DepthMapFactor = -1; &#125;; &#125;//namespace ORB_SLAM2#endif //SystemSetting 创建 SystemSetting.cc的函数具体实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;iostream&gt;#include"SystemSetting.h"using namespace std;namespace ORB_SLAM2 &#123; SystemSetting::SystemSetting(ORBVocabulary* pVoc):pVocavulary(pVoc) &#123; &#125; bool SystemSetting::LoadSystemSetting(const std::string strSettingPath) &#123; cout&lt;&lt;endl&lt;&lt;"Loading System Parameters form:"&lt;&lt;strSettingPath&lt;&lt;endl; cv::FileStorage fSettings(strSettingPath, cv::FileStorage::READ); width = fSettings["Camera.width"]; height = fSettings["Camera.height"]; fx = fSettings["Camera.fx"]; fy = fSettings["Camera.fy"]; cx = fSettings["Camera.cx"]; cy = fSettings["Camera.cy"]; cv::Mat tmpK = cv::Mat::eye(3,3,CV_32F); tmpK.at&lt;float&gt;(0,0) = fx; tmpK.at&lt;float&gt;(1,1) = fy; tmpK.at&lt;float&gt;(0,2) = cx; tmpK.at&lt;float&gt;(1,2) = cy; tmpK.copyTo(K); cv::Mat tmpDistCoef(4,1,CV_32F); tmpDistCoef.at&lt;float&gt;(0) = fSettings["Camera.k1"]; tmpDistCoef.at&lt;float&gt;(1) = fSettings["Camera.k2"]; tmpDistCoef.at&lt;float&gt;(2) = fSettings["Camera.p1"]; tmpDistCoef.at&lt;float&gt;(3) = fSettings["Camera.p2"]; const float k3 = fSettings["Camera.k3"]; if( k3!=0 ) &#123; tmpDistCoef.resize(5); tmpDistCoef.at&lt;float&gt;(4) = k3; &#125; tmpDistCoef.copyTo( DistCoef ); bf = fSettings["Camera.bf"]; fps= fSettings["Camera.fps"]; invfx = 1.0f/fx; invfy = 1.0f/fy; b = bf /fx; initialized = true; cout&lt;&lt;"- size:"&lt;&lt;width&lt;&lt;"x"&lt;&lt;height&lt;&lt;endl; cout&lt;&lt;"- fx:" &lt;&lt;fx&lt;&lt;endl; cout &lt;&lt; "- fy: " &lt;&lt; fy &lt;&lt; endl; cout &lt;&lt; "- cx: " &lt;&lt; cx &lt;&lt; endl; cout &lt;&lt; "- cy: " &lt;&lt; cy &lt;&lt; endl; cout &lt;&lt; "- k1: " &lt;&lt; DistCoef.at&lt;float&gt;(0) &lt;&lt; endl; cout &lt;&lt; "- k2: " &lt;&lt; DistCoef.at&lt;float&gt;(1) &lt;&lt; endl; if(DistCoef.rows==5) cout &lt;&lt; "- k3: " &lt;&lt; DistCoef.at&lt;float&gt;(4) &lt;&lt; endl; cout &lt;&lt; "- p1: " &lt;&lt; DistCoef.at&lt;float&gt;(2) &lt;&lt; endl; cout &lt;&lt; "- p2: " &lt;&lt; DistCoef.at&lt;float&gt;(3) &lt;&lt; endl; cout &lt;&lt; "- bf: " &lt;&lt; bf &lt;&lt; endl; //Load RGB parameter nRGB = fSettings["Camera.RGB"]; //Load ORB feature parameters nFeatures = fSettings["ORBextractor.nFeatures"]; fScaleFactor = fSettings["ORBextractor.scaleFactor"]; nLevels = fSettings["ORBextractor.nLevels"]; fIniThFAST = fSettings["ORBextractor.iniThFAST"]; fMinThFAST = fSettings["ORBextractor.minThFAST"]; cout &lt;&lt; endl &lt;&lt; "ORB Extractor Parameters: " &lt;&lt; endl; cout &lt;&lt; "- Number of Features: " &lt;&lt; nFeatures &lt;&lt; endl; cout &lt;&lt; "- Scale Levels: " &lt;&lt; nLevels &lt;&lt; endl; cout &lt;&lt; "- Scale Factor: " &lt;&lt; fScaleFactor &lt;&lt; endl; cout &lt;&lt; "- Initial Fast Threshold: " &lt;&lt; fIniThFAST &lt;&lt; endl; cout &lt;&lt; "- Minimum Fast Threshold: " &lt;&lt; fMinThFAST &lt;&lt; endl; //Load others parameters, if the sensor is MONOCULAR, the parameters is zero; //ThDepth = fSettings["ThDepth"]; //DepthMapFactor = fSettings["DepthMapFactor"]; fSettings.release(); return true; &#125;&#125; 创建 InitKeyFrame.h文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#ifndef INITKEYFRAME_H#define INITKEYFRAME_H#include "Thirdparty/DBoW2/DBoW2/BowVector.h"#include "Thirdparty/DBoW2/DBoW2/FeatureVector.h"#include "SystemSetting.h"#include &lt;opencv2/opencv.hpp&gt;#include "ORBVocabulary.h"#include "KeyFrameDatabase.h"//#include "MapPoints.h"namespace ORB_SLAM2&#123;#define FRAME_GRID_ROWS 48#define FRAME_GRID_COLS 64class SystemSetting;class KeyFrameDatabase;//class ORBVocabulary;class InitKeyFrame&#123;public: InitKeyFrame(SystemSetting &amp;SS); void UndistortKeyPoints(); bool PosInGrid(const cv::KeyPoint&amp; kp, int &amp;posX, int &amp;posY); void AssignFeaturesToGrid();public: ORBVocabulary* pVocabulary; //KeyFrameDatabase* pKeyFrameDatabase; long unsigned int nId; double TimeStamp; float fGridElementWidthInv; float fGridElementHeightInv; std::vector&lt;std::size_t&gt; vGrid[FRAME_GRID_COLS][FRAME_GRID_ROWS]; float fx; float fy; float cx; float cy; float invfx; float invfy; float bf; float b; float ThDepth; int N; std::vector&lt;cv::KeyPoint&gt; vKps; std::vector&lt;cv::KeyPoint&gt; vKpsUn; cv::Mat Descriptors; //it's zero for mono std::vector&lt;float&gt; vRight; std::vector&lt;float&gt; vDepth; DBoW2::BowVector BowVec; DBoW2::FeatureVector FeatVec; int nScaleLevels; float fScaleFactor; float fLogScaleFactor; std::vector&lt;float&gt; vScaleFactors; std::vector&lt;float&gt; vLevelSigma2; std::vector&lt;float&gt; vInvLevelSigma2; std::vector&lt;float&gt; vInvScaleFactors; int nMinX; int nMinY; int nMaxX; int nMaxY; cv::Mat K; cv::Mat DistCoef; &#125;;&#125; //namespace ORB_SLAM2#endif //INITKEYFRAME_H 创建 InitKeyFrame.cc的函数具体实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include "InitKeyFrame.h"#include &lt;opencv2/opencv.hpp&gt;#include "SystemSetting.h"namespace ORB_SLAM2&#123;InitKeyFrame::InitKeyFrame(SystemSetting &amp;SS):pVocabulary(SS.pVocavulary)//, pKeyFrameDatabase(SS.pKeyFrameDatabase)&#123; fx = SS.fx; fy = SS.fy; cx = SS.cx; cy = SS.cy; invfx = SS.invfx; invfy = SS.invfy; bf = SS.bf; b = SS.b; ThDepth = SS.ThDepth; nScaleLevels = SS.nLevels; fScaleFactor = SS.fScaleFactor; fLogScaleFactor = log(SS.fScaleFactor); vScaleFactors.resize(nScaleLevels); vLevelSigma2.resize(nScaleLevels); vScaleFactors[0] = 1.0f; vLevelSigma2[0] = 1.0f; for ( int i = 1; i &lt; nScaleLevels; i ++ ) &#123; vScaleFactors[i] = vScaleFactors[i-1]*fScaleFactor; vLevelSigma2[i] = vScaleFactors[i]*vScaleFactors[i]; &#125; vInvScaleFactors.resize(nScaleLevels); vInvLevelSigma2.resize(nScaleLevels); for ( int i = 0; i &lt; nScaleLevels; i ++ ) &#123; vInvScaleFactors[i] = 1.0f/vScaleFactors[i]; vInvLevelSigma2[i] = 1.0f/vLevelSigma2[i]; &#125; K = SS.K; DistCoef = SS.DistCoef; if( SS.DistCoef.at&lt;float&gt;(0)!=0.0) &#123; cv::Mat mat(4,2,CV_32F); mat.at&lt;float&gt;(0,0) = 0.0; mat.at&lt;float&gt;(0,1) = 0.0; mat.at&lt;float&gt;(1,0) = SS.width; mat.at&lt;float&gt;(1,1) = 0.0; mat.at&lt;float&gt;(2,0) = 0.0; mat.at&lt;float&gt;(2,1) = SS.height; mat.at&lt;float&gt;(3,0) = SS.width; mat.at&lt;float&gt;(3,1) = SS.height; mat = mat.reshape(2); cv::undistortPoints(mat, mat, SS.K, SS.DistCoef, cv::Mat(), SS.K); mat = mat.reshape(1); nMinX = min(mat.at&lt;float&gt;(0,0), mat.at&lt;float&gt;(2,0)); nMaxX = max(mat.at&lt;float&gt;(1,0), mat.at&lt;float&gt;(3,0)); nMinY = min(mat.at&lt;float&gt;(0,1), mat.at&lt;float&gt;(1,1)); nMaxY = max(mat.at&lt;float&gt;(2,1), mat.at&lt;float&gt;(3,1)); &#125; else &#123; nMinX = 0.0f; nMaxX = SS.width; nMinY = 0.0f; nMaxY = SS.height; &#125; fGridElementWidthInv=static_cast&lt;float&gt;(FRAME_GRID_COLS)/(nMaxX-nMinX); fGridElementHeightInv=static_cast&lt;float&gt;(FRAME_GRID_ROWS)/(nMaxY-nMinY); &#125;void InitKeyFrame::UndistortKeyPoints()&#123; if( DistCoef.at&lt;float&gt;(0) == 0.0) &#123; vKpsUn = vKps; return; &#125; cv::Mat mat(N,2,CV_32F); for ( int i = 0; i &lt; N; i ++ ) &#123; mat.at&lt;float&gt;(i,0) = vKps[i].pt.x; mat.at&lt;float&gt;(i,1) = vKps[i].pt.y; &#125; mat = mat.reshape(2); cv::undistortPoints(mat, mat, K, DistCoef, cv::Mat(), K ); mat = mat.reshape(1); vKpsUn.resize(N); for( int i = 0; i &lt; N; i ++ ) &#123; cv::KeyPoint kp = vKps[i]; kp.pt.x = mat.at&lt;float&gt;(i,0); kp.pt.y = mat.at&lt;float&gt;(i,1); vKpsUn[i] = kp; &#125;&#125;void InitKeyFrame::AssignFeaturesToGrid()&#123; int nReserve = 0.5f*N/(FRAME_GRID_COLS*FRAME_GRID_ROWS); for ( unsigned int i = 0; i &lt; FRAME_GRID_COLS; i ++ ) &#123; for ( unsigned int j = 0; j &lt; FRAME_GRID_ROWS; j ++) vGrid[i][j].reserve(nReserve); &#125; for ( int i = 0; i &lt; N; i ++ ) &#123; const cv::KeyPoint&amp; kp = vKpsUn[i]; int nGridPosX, nGridPosY; if( PosInGrid(kp, nGridPosX, nGridPosY)) vGrid[nGridPosX][nGridPosY].push_back(i); &#125;&#125;bool InitKeyFrame::PosInGrid(const cv::KeyPoint &amp;kp, int &amp;posX, int &amp;posY)&#123; posX = round((kp.pt.x-nMinX)*fGridElementWidthInv); posY = round((kp.pt.y-nMinY)*fGridElementHeightInv); if(posX&lt;0 || posX&gt;=FRAME_GRID_COLS ||posY&lt;0 || posY&gt;=FRAME_GRID_ROWS) return false; return true;&#125;&#125; （5）System相关文件的修改在System.h中添加函数定义： 1void LoadMap(const string &amp;filename); 添加声明： 1std::string mySettingFile; 在对应的System.cc中添加了定义 12345678//地图加载void System::LoadMap(const string &amp;filename)&#123; SystemSetting* mySystemSetting = new SystemSetting(mpVocabulary); mySystemSetting-&gt;LoadSystemSetting(mySettingFile); mpMap-&gt;Load(filename,mySystemSetting);&#125; 同时在构造函数函数中对mySettingFile成员变量赋值 1mySettingFile = strSettingsFile; //放在System::System里的check settings file 后面 2.2 测试修改CMakeLists.txt 文件 123456789101112131415161718192021222324#在add_library 中加入 src/InitkeyFrame.cc src/SystemSetting.ccadd_library($&#123;PROJECT_NAME&#125; SHAREDsrc/System.ccsrc/Tracking.ccsrc/LocalMapping.ccsrc/LoopClosing.ccsrc/ORBextractor.ccsrc/ORBmatcher.ccsrc/FrameDrawer.ccsrc/Converter.ccsrc/MapPoint.ccsrc/KeyFrame.ccsrc/Map.ccsrc/MapDrawer.ccsrc/Optimizer.ccsrc/PnPsolver.ccsrc/Frame.ccsrc/KeyFrameDatabase.ccsrc/Sim3Solver.ccsrc/Initializer.ccsrc/Viewer.ccsrc/InitKeyFrame.ccsrc/SystemSetting.cc) 一定要注意大小写！！！！网上写的是src/InitkeyFrame.cc，报错找了半天问题。 修改/ORB_SLAM2/Examples/ROS/ORB_SLAM2/src/ros_rgbd.cc文件中的main函数中加入如下语句： 1SLAM.LoadMap("/home/zj224/ORB_SLAM2/Examples/ROS/ORB_SLAM2/map.bin");//load the map 加在ros::spin()之前 重新编译ORB_SLAM2库 123456789cd ~/ORB_SLAM2chmod +x build.sh./build.sh source /opt/ros/kinetic/setup.shsource ~/.bashrcchmod +x build_ros.sh./build_ros.sh### 若出错，参考 ORB_slam实现 测试 12345678roscore### 新建终端roslaunch kinect2_bridge kinect2_bridge.launch### 新建终端cd ~/ORB_SLAM2/Examples/ROS/ORB_SLAM2rosrun ORB_SLAM2 RGBD /home/zj224/ORB_SLAM2/Vocabulary/ORBvoc.txt /home/zj224/ORB_SLAM2/Examples/RGB-D/kinect2.yaml### 就能看到加载的地图了 TODO加载功能也只是单纯地实现了地图加载，重定位、导航等问题有待进一步完善。这两天做地图保存和加载功能的实现，我发觉应该先学习ORB_SLAM2整个库的逻辑结构和代码解读，而不是直接按照博客的东西一顿忙改，功能实现了，但是不懂内部是不行的。接下来会先学习这个库，再去研究进一步的功能。]]></content>
      <categories>
        <category>slam</category>
      </categories>
      <tags>
        <tag>slam实现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ORB_SLAM2地图保存与加载（1）]]></title>
    <url>%2F2019%2F08%2F26%2FORB_SLAM2%E5%9C%B0%E5%9B%BE%E4%BF%9D%E5%AD%98%E4%B8%8E%E5%8A%A0%E8%BD%BD%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本文记录了ORB_SLAM2中地图保存的过程。参考博客：https://blog.csdn.net/qq_34254510/article/details/79969046http://www.cnblogs.com/mafuqiang/p/6972841.htmlhttps://blog.csdn.net/felaim/article/details/79667635https://blog.csdn.net/u014709760/article/details/86319090 1 地图保存1.1 地图元素分析所谓地图保存，就是保存地图“Map”中的各个元素，以及它们之间的关系，凡是跟踪过程中需要用到的东西自然也就是需要保存的对象。地图主要包含关键帧、3D地图点、BoW向量、共视图、生长树等，在跟踪过程中有三种跟踪模型和局部地图跟踪等过程，局部地图跟踪需要用到3D地图点、共视关系等元素，参考帧模型需要用到关键帧的BoW向量，重定位需要用到BoW向量、3D点等。所以基本上述元素都需要保存。 另一方面，关键帧也是一个抽象的概念（一个类），我们看看具体包含什么（其实都在关键帧类里面了），关键帧是从普通帧来的，所以得到视频帧后首先需要做的就是检测特征点，计算描述符，还有当前帧的相机位姿。成为关键帧之后需要有对应的ID编号，以及特征点进行三角化之后的3D地图点等。 关于3D地图点需要保存的就只有世界坐标了，至于其它的关联关系可以从关键帧获得。需要单独说的是在关键帧类中包含了特征点和描述符，所以BoW向量是不需要保存的（也没办法保存），只需要在加载了关键帧之后利用特征描述符重新计算即可。 所以现在需要保存的东西包括关键帧、3D地图点、共视图、生长树。 1.2 源码修改SLAM对地图维护的操作均在Map.cc这个函数类中，所以要保存地图，我们需要在这个文件中添加相应代码。 （1）修改Map.h头文件在/ORB_SLAM2/include/Map.h文件中的Map类中添加如下函数： 在Map.h的头文件中要添加Converter.h 123456789public: //保存地图信息 void Save(const string &amp;filename);protected: //保存地图点和关键帧 void SaveMapPoint(ofstream &amp;f,MapPoint* mp); void SaveKeyFrame(ofstream &amp;f,KeyFrame* kf); std::map&lt;MapPoint*, unsigned long int&gt; mmpnMapPointsIdx; void GetMapPointsIdx(); （2）修改Map.cc文件在/ORB_SLAM2/src/Map.cc文件中添加第一步中函数的实现。 Save()函数的实现过程： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//保存地图信息void Map::Save ( const string&amp; filename )&#123; //Print the information of the saving map cerr&lt;&lt;"Map.cc :: Map Saving to "&lt;&lt;filename &lt;&lt;endl; ofstream f; f.open(filename.c_str(), ios_base::out|ios::binary); //Number of MapPoints unsigned long int nMapPoints = mspMapPoints.size(); f.write((char*)&amp;nMapPoints, sizeof(nMapPoints) ); //Save MapPoint sequentially for ( auto mp: mspMapPoints )&#123; //Save MapPoint SaveMapPoint( f, mp ); // cerr &lt;&lt; "Map.cc :: Saving map point number: " &lt;&lt; mp-&gt;mnId &lt;&lt; endl; &#125; //Print The number of MapPoints cerr &lt;&lt; "Map.cc :: The number of MapPoints is :"&lt;&lt;mspMapPoints.size()&lt;&lt;endl; //Grab the index of each MapPoint, count from 0, in which we initialized mmpnMapPointsIdx GetMapPointsIdx(); //Print the number of KeyFrames cerr &lt;&lt;"Map.cc :: The number of KeyFrames:"&lt;&lt;mspKeyFrames.size()&lt;&lt;endl; //Number of KeyFrames unsigned long int nKeyFrames = mspKeyFrames.size(); f.write((char*)&amp;nKeyFrames, sizeof(nKeyFrames)); //Save KeyFrames sequentially for ( auto kf: mspKeyFrames ) SaveKeyFrame( f, kf ); for (auto kf:mspKeyFrames ) &#123; //Get parent of current KeyFrame and save the ID of this parent KeyFrame* parent = kf-&gt;GetParent(); unsigned long int parent_id = ULONG_MAX; if ( parent ) parent_id = parent-&gt;mnId; f.write((char*)&amp;parent_id, sizeof(parent_id)); //Get the size of the Connected KeyFrames of the current KeyFrames //and then save the ID and weight of the Connected KeyFrames unsigned long int nb_con = kf-&gt;GetConnectedKeyFrames().size(); f.write((char*)&amp;nb_con, sizeof(nb_con)); for ( auto ckf: kf-&gt;GetConnectedKeyFrames()) &#123; int weight = kf-&gt;GetWeight(ckf); f.write((char*)&amp;ckf-&gt;mnId, sizeof(ckf-&gt;mnId)); f.write((char*)&amp;weight, sizeof(weight)); &#125; &#125; // Save last Frame ID // SaveFrameID(f); f.close(); cerr&lt;&lt;"Map.cc :: Map Saving Finished!"&lt;&lt;endl;&#125; 存储地图点函数——SaveMapPoint()函数的实现： 123456789void Map::SaveMapPoint( ofstream&amp; f, MapPoint* mp)&#123; //Save ID and the x,y,z coordinates of the current MapPoint f.write((char*)&amp;mp-&gt;mnId, sizeof(mp-&gt;mnId)); cv::Mat mpWorldPos = mp-&gt;GetWorldPos(); f.write((char*)&amp; mpWorldPos.at&lt;float&gt;(0),sizeof(float)); f.write((char*)&amp; mpWorldPos.at&lt;float&gt;(1),sizeof(float)); f.write((char*)&amp; mpWorldPos.at&lt;float&gt;(2),sizeof(float));&#125; 存储关键帧函数——SaveKeyFrame()函数的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263void Map::SaveKeyFrame( ofstream &amp;f, KeyFrame* kf )&#123; //Save the ID and timesteps of current KeyFrame f.write((char*)&amp;kf-&gt;mnId, sizeof(kf-&gt;mnId)); // cout &lt;&lt; "saving kf-&gt;mnId = " &lt;&lt; kf-&gt;mnId &lt;&lt;endl; f.write((char*)&amp;kf-&gt;mTimeStamp, sizeof(kf-&gt;mTimeStamp)); //Save the Pose Matrix of current KeyFrame cv::Mat Tcw = kf-&gt;GetPose(); ////Save the rotation matrix // for ( int i = 0; i &lt; Tcw.rows; i ++ ) // &#123; // for ( int j = 0; j &lt; Tcw.cols; j ++ ) // &#123; // f.write((char*)&amp;Tcw.at&lt;float&gt;(i,j), sizeof(float)); // //cerr&lt;&lt;"Tcw.at&lt;float&gt;("&lt;&lt;i&lt;&lt;","&lt;&lt;j&lt;&lt;"):"&lt;&lt;Tcw.at&lt;float&gt;(i,j)&lt;&lt;endl; // &#125; // &#125; //Save the rotation matrix in Quaternion std::vector&lt;float&gt; Quat = Converter::toQuaternion(Tcw); for ( int i = 0; i &lt; 4; i ++ ) f.write((char*)&amp;Quat[i],sizeof(float)); //Save the translation matrix for ( int i = 0; i &lt; 3; i ++ ) f.write((char*)&amp;Tcw.at&lt;float&gt;(i,3),sizeof(float)); //Save the size of the ORB features current KeyFrame //cerr&lt;&lt;"kf-&gt;N:"&lt;&lt;kf-&gt;N&lt;&lt;endl; f.write((char*)&amp;kf-&gt;N, sizeof(kf-&gt;N)); //Save each ORB features for( int i = 0; i &lt; kf-&gt;N; i ++ ) &#123; cv::KeyPoint kp = kf-&gt;mvKeys[i]; f.write((char*)&amp;kp.pt.x, sizeof(kp.pt.x)); f.write((char*)&amp;kp.pt.y, sizeof(kp.pt.y)); f.write((char*)&amp;kp.size, sizeof(kp.size)); f.write((char*)&amp;kp.angle,sizeof(kp.angle)); f.write((char*)&amp;kp.response, sizeof(kp.response)); f.write((char*)&amp;kp.octave, sizeof(kp.octave)); //Save the Descriptors of current ORB features f.write((char*)&amp;kf-&gt;mDescriptors.cols, sizeof(kf-&gt;mDescriptors.cols)); //kf-&gt;mDescriptors.cols is always 32 here. for (int j = 0; j &lt; kf-&gt;mDescriptors.cols; j ++ ) f.write((char*)&amp;kf-&gt;mDescriptors.at&lt;unsigned char&gt;(i,j), sizeof(char)); //Save the index of MapPoints that corresponds to current ORB features unsigned long int mnIdx; MapPoint* mp = kf-&gt;GetMapPoint(i); if (mp == NULL ) mnIdx = ULONG_MAX; else mnIdx = mmpnMapPointsIdx[mp]; f.write((char*)&amp;mnIdx, sizeof(mnIdx)); &#125; // Save BoW for relocalization. // f.write((char*)&amp;kf-&gt;mBowVec, sizeof(kf-&gt;mBowVec));&#125; GetMapPointsIdx()函数的实现过程为： 12345678910void Map::GetMapPointsIdx()&#123; unique_lock&lt;mutex&gt; lock(mMutexMap); unsigned long int i = 0; for ( auto mp: mspMapPoints ) &#123; mmpnMapPointsIdx[mp] = i; i += 1; &#125;&#125; （3）修改Converter相关文件关于旋转矩阵的存储可以通过四元数或矩阵的形式存储，如果使用四元数需要自定义一个矩阵和四元数相互转换的函数，在Converter.cc类里面添加如下函数： 123456789101112cv::Mat Converter::toCvMat(const std::vector&lt;float&gt;&amp; v)&#123; Eigen::Quaterniond q; q.x() = v[0]; q.y() = v[1]; q.z() = v[2]; q.w() = v[3]; Eigen::Matrix&lt;double,3,3&gt; eigMat(q); cv::Mat M = toCvMat(eigMat); return M;&#125; 在Converter.h里面加上如下函数定义 1static cv::Mat toCvMat( const std::vector&lt;float&gt;&amp; v )； （4）System文件修改上述修改完成之后，还需要对system.h和system.cc文件进行修改，分别添加声明和定义。system.h文件： 1void SaveMap(const string &amp;filename); system.cc文件: 12345//地图保存void System::SaveMap(const string &amp;filename)&#123; mpMap-&gt;Save(filename);&#125; 1.3 测试做完这些修改之后，在Examples文件中对应的示例程序中加入地图存储代码即可实现地图存储功能。 修改/ORB_SLAM2/Examples/ROS/ORB_SLAM2/src/ros_rgbd.cc文件中的main函数中加入如下语句： 1SLAM.SaveMap("map.bin"); 重新编译ORB_SLAM2库 123456789cd ~/ORB_SLAM2chmod +x build.sh./build.sh source /opt/ros/kinetic/setup.shsource ~/.bashrcchmod +x build_ros.sh./build_ros.sh### 若出错，参考 ORB_slam实现 测试 12345678roscore### 新建终端roslaunch kinect2_bridge kinect2_bridge.launch### 新建终端cd ~/ORB_SLAM2/Examples/ROS/ORB_SLAM2rosrun ORB_SLAM2 RGBD /home/zj224/ORB_SLAM2/Vocabulary/ORBvoc.txt /home/zj224/ORB_SLAM2/Examples/RGB-D/kinect2.yaml### 建图完成后 ctrl+C 地图保存在/ORB_SLAM2/Examples/ROS/ORB_SLAM2]]></content>
      <categories>
        <category>slam</category>
      </categories>
      <tags>
        <tag>slam实现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[yilia 主题一些问题解决]]></title>
    <url>%2F2019%2F08%2F25%2Fyilia%20%E4%B8%BB%E9%A2%98%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[1 公式无法显示yilia 目录下有一个_config.yml 编辑里面的 123#数学公式mathjax: false 将false 改为true即可 2 修改头像yilia 目录下有一个_config.yml 编辑里面的 12#你的头像urlavatar: /img/1.jpg 将头像图片放在yilia/source/img中即可 3 上传图片配置 hexo 的_config.yml 1post_asset_folder: true 安装上传本地图片插件 1npm install hexo-asset-image --save ### 先cd 到你的文件夹 新建博客 12hexo n &quot;xxx&quot;# 在/source/_posts路径下会生成一个xxx.md和xxx文件 在md文件中引入图片，将你的图片放入xxx文件夹中 1![你想输入的替代文字](xxxx/图片名.jpg)]]></content>
      <categories>
        <category>问题解决</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ORB_SLAM2 在ROS中使用KinectV2实现]]></title>
    <url>%2F2019%2F08%2F24%2FORB_SLAM2%20%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[安装依赖包12345678910111213141516171819202122ssh -T git@github.comsudo apt-get install libboost-all-dev libblas-dev liblapack-dev#### 安装 Pangolingit clone git@github.com:stevenlovegrove/Pangolin.gitcd Pangolinmkdir buildcd buildcmake ..cmake --build .##### 安装 eigenhttp://eigen.tuxfamily.org/index.php?title=Main_Page ### 下载eigen包 解压cd eigenmkdir buildcd buildcmake ..makesudo make installsudo apt-get install libopencv-dev libeigen3-dev libqt4-dev qt4-qmake libqglviewer-dev libsuitesparse-dev libcxsparse3.1.4 libcholmod3.0.6 安装ORB_SLAM21234567891011git clone git@github.com:raulmur/ORB_SLAM2.gitcd ORB_SLAM2chmod +x build.shgedit ./build.sh修改最后一行，改为make./build.sh### 若报错 error: ‘usleep’ was not declaredcd ORB_SLAM2/srcgedit System.cc ### 报错的其他文件一样，不再一一说明，很多，要有耐心 T_T添加头文件 #include &lt;unistd.h&gt; 配置KINECT 苏齐光已经整理了一个Kinect配置文件，这里不再赘述。 KINECT 标定制作标定板chess5x7x0.03.pdfchess7x9x0.025.pdfchess9x11x0.02.pdf 这里我选择的是第三个 ！！！这里一定要注意，9x11实际上方格数是10x12 ！！！这里我搞错了耽误了一天。。。 建立临时文件夹以免图片太多看起来很乱 12mkdir ~/kinect_cal_tempcd kinect_cal_temp 标定步骤12345678910111213141516171819202122rosrun kinect2_bridge kinect2_bridge _fps_limit:=2 ### 先运行roscore### 显示的 [ INFO] [Kinect2Bridge::initDevice] device serial: 019968265047 后面的数为设备串口号### 在我的/home/catkin_ws/src/iai_kinect2/kinect2_bridge/data的文件夹里建立一个文件夹，取名叫 019968265047### 标定彩色摄像头：rosrun kinect2_calibration kinect2_calibration chess9x11x0.02 record color ### 按空格保存图片，10+张，后面一样rosrun kinect2_calibration kinect2_calibration chess9x11x0.02 calibrate color生成calib_color.yaml 文件 ### 标定红外rosrun kinect2_calibration kinect2_calibration chess9x11x0.02 record irrosrun kinect2_calibration kinect2_calibration chess9x11x0.02 calibrate ir### 会生成calib_ir.yaml 文件### 帧同步标定rosrun kinect2_calibration kinect2_calibration chess9x11x0.02 record syncrosrun kinect2_calibration kinect2_calibration chess9x11x0.02 calibrate sync### 会生成calib_pose.yaml 文件 ### 深度标定rosrun kinect2_calibration kinect2_calibration chess9x11x0.02 calibrate depth### 会生成calib_depth.yaml 文件 标定后的文件calib_color.yaml calib_ir.yaml calib_pose.yaml calib_depth.yaml 需要放到/home/catkin_ws/src/iai_kinect2/kinect2_bridge/data/019968265047这个文件夹里 标定至此完成！ 修改 ORB-SLAM2文件改动 1修改/home/zj224/ORB_SLAM2/Examples/ROS/ORB_SLAM2/src 中的 ros_rgbd.cc 文件的 main 函数： 12message_filters::Subscriber&lt;sensor_msgs::Image&gt; rgb_sub(nh, &quot;/camera/rgb/image_raw&quot;, 1);message_filters::Subscriber&lt;sensor_msgs::Image&gt; depth_sub(nh,&quot;camera/depth_registered/image_raw&quot;, 1); 改为： 12message_filters::Subscriber&lt;sensor_msgs::Image&gt; rgb_sub(nh,&quot;/kinect2/qhd/image_color&quot;,1);message_filters::Subscriber&lt;sensor_msgs::Image&gt; depth_sub(nh,&quot;/kinect2/qhd/image_depth_rect&quot;,1); 改动 2设置标定相机参数，仿照/Examples/RGB-D/TUM1.yaml 根据之前得到的 calib_color.yaml 修改并另存为 kinect2.yaml 1234567891011121314# Camera calibration and distortion parameters (OpenCV) Camera.fx: 1.0679837281443886e+03Camera.fy: 1.0697937777504162e+03Camera.cx: 9.3735357113460532e+02Camera.cy: 5.5068347235162321e+02Camera.k1: 8.4529458178805153e-02Camera.k2: -1.3472803452135898e-01Camera.p1: 2.4226930973738920e-03Camera.p2: -3.1065128414445530e-03Camera.k3: 3.3625687689377249e-03Camera.width: 1920Camera.height: 1080 改动 3123sudo gedit ~/.bashrc添加 export ROS_PACKAGE_PATH=$&#123;ROS_PACKAGE_PATH&#125;:/home/zj224/ORB_SLAM2/Examples/ROSsource ~/.bashrc 再次编译 ORB_SLAM2 12345678cd ~/ORB_SLAM2chmod +x build.sh./build.sh source /opt/ros/kinetic/setup.shchmod +x build_ros.sh./build_ros.sh 报错 [rosbuild] rospack found package “ORB_SLAM2” at “”, but the current directory is “/home/zj224/ORB_SLAM2/Examples/ROS/ORB_SLAM2”. 运行： 12sudo ln -s /home/ORB_SLAM2/Examples/ROS/ORB_SLAM2 /opt/ros/kinetic/share/ORB_SLAM2source ~/.bashrc 报错 CMakeFiles/RGBD.dir/src/ros_rgbd.cc.o: undefined reference to symbol ‘_ZN5boost6system15system_categoryEv’ 将/usr/lib/x86_64-linux-gnu/libboost_system.so/usr/lib/x86_64-linux-gnu/libboost_filesystem.so两个文件复制到 ORB_SLAM2 / lib修改/home/zj224/ORB_SLAM2/Examples/ROS/ORB_SLAM2 中的 CMakeLists.txt修改前： 123456789set(LIBS $&#123;OpenCV_LIBS&#125; $&#123;EIGEN3_LIBS&#125;$&#123;Pangolin_LIBRARIES&#125;$&#123;PROJECT_SOURCE_DIR&#125;/../../../Thirdparty/DBoW2/lib/libDBoW2.so$&#123;PROJECT_SOURCE_DIR&#125;/../../../Thirdparty/g2o/lib/libg2o.so$&#123;PROJECT_SOURCE_DIR&#125;/../../../lib/libORB_SLAM2.so) 修改后： 12345678910set(LIBS $&#123;OpenCV_LIBS&#125; $&#123;EIGEN3_LIBS&#125;$&#123;Pangolin_LIBRARIES&#125;$&#123;PROJECT_SOURCE_DIR&#125;/../../../Thirdparty/DBoW2/lib/libDBoW2.so$&#123;PROJECT_SOURCE_DIR&#125;/../../../Thirdparty/g2o/lib/libg2o.so$&#123;PROJECT_SOURCE_DIR&#125;/../../../lib/libORB_SLAM2.so-lboost_system) 运行程序1roscore 新建一个终端 1roslaunch kinect2_bridge kinect2_bridge.launch 新建一个终端 12cd ~/ORB_SLAM2/Examples/ROS/ORB_SLAM2rosrun ORB_SLAM2 RGBD /home/zj224/ORB_SLAM2/Vocabulary/ORBvoc.txt /home/zj224/ORB_SLAM2/Examples/RGB-D/kinect2.yaml]]></content>
      <categories>
        <category>slam</category>
      </categories>
      <tags>
        <tag>slam实现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回环检测]]></title>
    <url>%2F2019%2F08%2F22%2F%E5%9B%9E%E7%8E%AF%E6%A3%80%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[1 什么是回环检测？ 在视觉slam问题中，位姿的估计往往是一个递推的过程，即由上一帧位姿解算当前帧位姿，因此其中的误差便这样一帧一帧的传递下去，也就是我们所说的累计误差。 我们的位姿约束都是与上一帧建立的，第五帧的位姿误差中便已经积累了前面四个约束中的误差。但如果我们发现第五帧位姿不一定要由第四帧推出来，还可以由第二帧推算出来，显然这样计算误差会小很多，因为只存在两个约束的误差了。像这样与之前的某一帧建立位姿约束关系就叫做回环。回环通过减少约束数，起到了减小累计误差的作用。 那么我们怎么知道可以由第二帧推算第五帧位姿呢？也许第一帧、第三帧也可以呢。确实，我们之所以用前一帧递推下一帧位姿，因为这两帧足够近，肯定可以建立两帧的约束，但是距离较远的两帧就不一定可以建立这样的约束关系了。找出可以建立这种位姿约束的历史帧，就是回环检测。 2 回环检测的意义 举例来说，假设我们在前端提取了特征，然后忽略掉特征点，在后端使用 Pose Graph优化整个轨迹，如图 12-1(a) 所示。由于前端给出的只是局部的位姿间约束，比方说，可能是$x_1 − x_2$， $x_ 2 − x _3 $等等。但是，由于 $x _1$ 的估计存在误差,而 $x_2 $是根据 $x _1$ 决定的,$x_3$是由$x_2 $决定的。以此类推，误差就会被累积起来，使得后端优化的结果如图 12-1 (b)所示，慢慢地趋向不准确。而回环检测则可以消除这种累积误差，如图12-1 (c)所示。 回环检测对于 SLAM 系统意义重大。它关系到我们估计的轨迹和地图在长时间下的正确性。另一方面，由于回环检测提供了当前数据与所有历史数据的关联，在跟踪算法丢失之后，我们还可以利用回环检测进行重定位。因此，回环检测对整个 SLAM 系统精度与鲁棒性的提升，是非常明显的。甚至在某些时候，我们把仅有前端和局部后端的系统称为VO，而把带有回环检测和全局后端的称为 SLAM。 3 回环检测的方法 回环的产生是因为相机经过了同一个地方，采集到了相似的数据。而回环检测的关键，就是如何有效地检测出相机经过同一个地方这件事。 回环检测的方法大致分为两种思路：基于里程计的几何关系(Odometry based)，或基于外观(Appearance based)。这里只讲最主流的基于外观的回环检测方法。 它和前端后端的估计都无关，仅根据两张图像的相似性确定回环检测关系。这种做法摆脱了累计误差，使回环检测模块成为 SLAM 系统中一个相对独立的模块（当然前端可以为它提供特征点）。 3.1 准确率和召回率(Precision &amp; Recall)$$Precision = TP/(TP+FP) , Recall = TP/(TP+FN)$$ 准确率描述的是，算法提取的所有回环中，确实是真实回环的概率。 召回率则是说，在所有真实回环中，被正确检测出来的概率。 在 SLAM 中，我们对准确率要求更高，而对召回率则相对宽容一些。 3.2 词袋模型 在基于外观的回环检测算法中，核心问题是如何计算图像间的相似性。 最为直观的想法就是直接对比两个图像的矩阵，将两个图像相减，但是由于灰度是一种不稳定的测量值，严重受环境光照和相机曝光的影响，此外如果相机视角发生少量变化，同样的物体，同样的光照，像素发生了位移就会导致灰度值产生巨大差异。 词袋，也就是 Bag-of-Words（BoW），目的是用”图像上有哪几种特征“来描述一个图像。例如，如果某个照片，我们说里面有一个人、一辆车；而另一张则有两个人、一只狗。根据这样的描述，可以度量这两个图像的相似性。 ”人、车、狗“就是单词（Word）；许多单词放在一起组成字典（dictionary）。 “人”、“车”、“狗”都是记录在字典中的单词，我们不妨记为 $w_1,w_2,w_3$ 。然后，对于任意图像 A，根据它们含有的单词，可记为: $A=1\times w_1+1\times w_2+0\times w_3$ （即，$[1,1,0]^T$）来表示图像A中有一个“人”，一辆“车”，没有“狗”。这种方式只考虑有没有，不考虑在哪儿，能保证相机发生少量运动时，描述向量不发生变化。 3.3 字典 按照前面的介绍，字典由很多单词组成，而每一个单词代表了一个概念。一个单词与一个单独的特征点不同，它不是从单个图像上提取出来的，而是某一类特征的组合。所以，字典生成问题类似于一个聚类(Clustering)问题。 聚类问题是无监督机器学习(Unsupervised ML)中一个特别常见的问题，而K-means 是一个非常简单有效的方法。当我们有 N 个数据，想要归成 k 个类，K-means的步骤为： 随机选取 k 个中心点：$c_1 , . . . , c_k $； 对每一个样本，计算与每个中心点之间的距离，取最小的作为它的归类； 重新计算每个类的中心点。 如果每个中心点都变化很小，则算法收敛，退出；否则返回 1。 考虑到字典的通用性 ，,我们通常会使用一个较大规模的字典。这就需要使用k叉树来表达字典了。假定我们有 N 个特征点，希望构建一个深度为 d，每次分叉为 k 的树，那么做法如下：（如图12-4） 在根节点，用 k-means 把所有样本聚成 k 类。这样得到了第一层。 对第一层的每个节点，把属于该节点的样本再聚成 k 类，得到下一层。 依此类推，最后得到叶子层。叶子层即为所谓的 Words。 3.4 相似度计算 当我们建立了字典，并对两个图片分析特征点得到他们的词袋后，如何计算它们的相似的便成为一个非常关键的问题。考虑到，不同的单词在区分性上的重要性并不相同。例如“的”、“是”这样的字可能在许许多多的句子中出现，我们无法根据它们判别句子的类型；但如果有“文档”、“足球”这样的单词，对判别句子的作用就更大一些，可以说它们提供了更多信息。所以概括的话，我们希望对单词的区分性或重要性加以评估，给它们不同的权值以起到更好的效果。 在文本检索中，常用的一种做法称为 TF-IDF（Term Frequency–Inverse Document Frequency）。TF 部分的思想是，某单词在一个图像中经常出现，它的区分度就高。另一方面，IDF 的思想是，某单词在字典中出现的频率越低，则分类图像时区分度越高。 我们统计某个叶子节点 $w_i$ 中的特征数量相对于所有特征数量的比例，作为 IDF 部分。假设所有特征数量为 $n$，$w_i $数量为$n_i$ ，那么该单词的 IDF 为：$IDF_i=log\frac{n}{n_i}$ 另一方面，TF 部分则是指某个特征在单个图像中出现的频率。假设图像 A 中，单词$w_i $出现了$n_i$ 次，而一共出现的单词次数为$n$，那么 TF 为：$TF_i=\frac{n_i}{n}$ 单词$w_i $的权重等于：$\eta_i=TF_i\times IDF_i$ 考虑权重以后，对于某个图像 A，它的特征点可对应到许多个单词，组成它的 Bag-of-Words: $$A=[(w_1,\eta_1),(w_2,\eta_2),\cdots,(w_N,\eta_N)]=v_A$$ 给定 $v_A$和 $v_B$计算差异：$s(v_A-v_B)=$$\sqrt{\sum_{i=1}^{N}{|v_{Ai}-v_{Bi}|^2}}$ 欧氏距离；余弦相似度。。。 相似性评分的处理 对于一些相识度本身就很高的场景，单纯的计算相识度、设置阈值是很难取得好的效果的。这时候需要相对相似度的评分处理。取一个先验相似度 $s(v_t,v_{t-\Delta t})$，它表示某时刻关键帧图像与上一时刻的关键帧的相似性。然后，其他的分值都参照这个值进行归一化:$s(v_t,v_{t_j})’=s(v_t,v_{t_j})/s(v_t,v_{t-\Delta t})$，再设置阈值。 4 回环检测的实现主要使用的库基础库：DBoW3 https://github.com/rmsalinas/DBow3 slam方法库：ORB_SLAM2 https://github.com/raulmur/ORB_SLAM2 改进参考： https://github.com/Ewenwan/ORB_SLAM2_SSD_Semantic 参考资料： https://www.cnblogs.com/slamtec/p/9837877.html 视觉slam十四讲_高翔]]></content>
      <categories>
        <category>slam</category>
      </categories>
      <tags>
        <tag>slam理论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu系统备份为ISO文件]]></title>
    <url>%2F2019%2F08%2F21%2Fubuntu%E7%B3%BB%E7%BB%9F%E5%A4%87%E4%BB%BD%E4%B8%BAISO%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[1 安装systemback12345sudo add-apt-repository ppa:nemh/systembacksudo apt-get updatesudo apt-get install systemback unionfs-fuse 2 制作当前系统的镜像该软件还可以设置还原点，进行系统还原，操作很简单，一键设置一键还原，这里不再介绍 打开systemback 输入密码 选择Live system create 勾选 include the user data files 点击create new 生成备份结束后，选择备份文件，点击Convert to ISO 到你保存的路径下就能看到整体打包的系统ISO文件。 3 问题处理我进行完成2.5后，无法转为ISO文件，原因为系统大小大于4GB，解决办法如下： 创建sblive文件夹并解压通过systemback生成的.sblive 文件至sblive文件夹: 12mkdir sblivetar -xf /home/systemback_live_2019-08-16.sblive -C sblive ## 中间为你创建的镜像 重命名 syslinux 至 isolinux: 12mv sblive/syslinux/syslinux.cfg sblive/syslinux/isolinux.cfgmv sblive/syslinux sblive/isolinux 安装 cdtools 123456789101112sudo apt-get install aria2 aria2c -s 10 https://nchc.dl.sourceforge.net/project/cdrtools/alpha/cdrtools-3.02a07.tar.gz tar -xzvf cdrtools-3.02a07.tar.gz cd /home/hadoop/cdrtools-3.02 make sudo make install 生成 ISO 文件: 123cd ~ /opt/schily/bin/mkisofs -iso-level 3 -r -V sblive -cache-inodes -J -l -b isolinux/isolinux.bin -no-emul-boot -boot-load-size 4 -boot-info-table -c isolinux/boot.cat -o sblive.iso sblive 等待执行完成，我们便可在主文件夹下看见生成的sblive.iso镜像文件了 该部分来自：本文链接：https://blog.csdn.net/qq_39940390/article/details/94980229 4 系统安装1 虚拟机 VM14虚拟机的安装包和ubuntu16.04的ISO文件在实验室三星U盘里 安装过程可以参考 https://blog.csdn.net/qq_28090573/article/details/82724910，非常详细 我尝试了在虚拟机中安装我自己生成的ISO文件，但是卡在登陆界面无法进入，在网上查了很久尝试了很多方法也没能解决，最后选择了安装原生ubuntu的ISO文件 2 双系统未尝试安装 总结 systemback 的系统还原功能亲测可用，但是还原点会占一定的存储空间，建议只在重大环境安装前后备份使用 systemback 的ISO文件刻录功能亲测可用，但是得到的ISO文件在安装过程中存在问题，目前没有证明得到的ISO文件可以完成安装（虽然网上很多成功的。。。。）]]></content>
      <categories>
        <category>问题解决</category>
      </categories>
      <tags>
        <tag>Ubuntu系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[激光雷达和ROS结合]]></title>
    <url>%2F2019%2F08%2F21%2F%E6%BF%80%E5%85%89%E9%9B%B7%E8%BE%BE%E5%92%8CROS%E7%BB%93%E5%90%88%2F</url>
    <content type="text"><![CDATA[网址：https://github.com/slamtec/rplidar_ros 1 下载整个rplidar_ros包 cd catkin_ws/src ##到你的工作空间的src git clone https://github.com/Slamtec/rplidar_ros.git cd .. catkin_make source ./devel/setup.bash 2 运行rplidar_ros包###每次雷达重新连接电脑时，需要进行2.1前的步骤，如果USB口不是USB0，需要改动launch文件中的 param name=”serial_port” type=”string” value=”/dev/rplidar”/ ls -l /dev |grep ttyUSB #检查雷达的USB口 sudo chmod 666 /dev/ttyUSB0 #赋予权限 2.1在rviz中显示 roslaunch rplidar_ros view_rplidar_a3.launch 2.2在终端显示 roslaunch rplidar_ros rplidar_a3.launch #启动雷达 rosrun rplidar_ros rplidarNodeClient #在另外一个终端打开]]></content>
      <categories>
        <category>slam</category>
      </categories>
      <tags>
        <tag>slam实现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[激光雷达安装步骤]]></title>
    <url>%2F2019%2F08%2F21%2F%E6%BF%80%E5%85%89%E9%9B%B7%E8%BE%BE%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4%2F</url>
    <content type="text"><![CDATA[1. 安装SDK1.1 下载相关文件 网址：http://go.slamtec.com/rplidar/a3/download 我已将相关文件下载至思岚雷达文件夹 后续工作可以按照我的说明，不必去看SDK说明，里面包含Windows、macos等安装，很杂。 1.2 编译SDK 解压SDK压缩包至根目录，重命名为rplidar_sdk cd ~/rplidar_sdk/sdk make 1.3 交叉编译 我没有进行这一步骤，因为目前不知道是否需要 透过交叉编译特性,SDK 的编译系统支持编译产生其他平台/系统的二进制可执行文件。注意: 该功能仅针对使用 Makefile 的环境.交叉编译特性将通过调用 cross_compile.sh 脚本激活。该脚本的调用语法如下:CROSS_COMPILE_PREFIX= ./cross_compile.sh例如: CROSS_COMPILE_PREFIX=arm-linux-gnueabihf ./cross_compile.sh 2. 连接雷达和PC 直接接电脑即可 3. 运行DEMO3.1 ultra_simple 该示例程序演示 PC 通过串口与 RPLIDAR 进行连接，并不断的将 RPLIDAR 扫描数据输出的最简单过程。 ls /dev/ttyUSB* ##这个命令可以检测你的雷达USB编号，看你雷达连上没 cd ~/rplidar_sdk/sdk/output/Linux/Release ./ultra_simple /dev/ttyUSB0 能转起来就说明安装好了]]></content>
      <categories>
        <category>slam</category>
      </categories>
      <tags>
        <tag>slam实现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修改默认打开方式]]></title>
    <url>%2F2019%2F08%2F21%2F%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[刚装上Typaro时markdown文件没有默认用它打开，而且打开方式中也找不到，可以采用以下方法 个人的打开方式保存在~/.local/share/applications/mimeapps.list 1sudo gedit ~/.local/share/applications/mimeapps.list 修改mimeapps.list 文件，在文件末尾添加 1text/markdown=typora.desktop 完成。]]></content>
      <categories>
        <category>问题解决</category>
      </categories>
      <tags>
        <tag>Ubuntu系统</tag>
      </tags>
  </entry>
</search>
